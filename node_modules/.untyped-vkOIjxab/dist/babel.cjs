'use strict';

const t = require('@babel/types');
const utils = require('./shared/untyped.07613105.cjs');
require('scule');

function _interopNamespaceDefault(e) {
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return n;
}

const t__namespace = /*#__PURE__*/_interopNamespaceDefault(t);

const version = "1.2.2";

const babelPluginUntyped = function(api) {
  api.cache.using(() => version);
  return {
    visitor: {
      VariableDeclaration(p) {
        const declaration = p.node.declarations[0];
        if (t__namespace.isIdentifier(declaration.id) && (t__namespace.isFunctionExpression(declaration.init) || t__namespace.isArrowFunctionExpression(declaration.init))) {
          const newDeclaration = t__namespace.functionDeclaration(
            declaration.id,
            declaration.init.params,
            declaration.init.body
          );
          newDeclaration.returnType = declaration.init.returnType;
          p.replaceWith(newDeclaration);
        }
      },
      ObjectProperty(p) {
        if (p.node.leadingComments) {
          const schema = parseJSDocs(
            p.node.leadingComments.filter((c) => c.type === "CommentBlock").map((c) => c.value)
          );
          const valueNode = p.node.value.type === "TSTypeAssertion" || p.node.value.type === "TSAsExpression" ? p.node.value.expression : p.node.value;
          if (valueNode.type === "ObjectExpression") {
            const schemaProp = valueNode.properties.find(
              (prop) => "key" in prop && prop.key.type === "Identifier" && prop.key.name === "$schema"
            );
            if (schemaProp && "value" in schemaProp) {
              if (schemaProp.value.type === "ObjectExpression") {
                schemaProp.value.properties.push(...astify(schema).properties);
              }
            } else {
              valueNode.properties.unshift(
                ...astify({ $schema: schema }).properties
              );
            }
          } else {
            p.node.value = t__namespace.objectExpression([
              t__namespace.objectProperty(t__namespace.identifier("$default"), valueNode),
              t__namespace.objectProperty(t__namespace.identifier("$schema"), astify(schema))
            ]);
          }
          p.node.leadingComments = [];
        }
      },
      FunctionDeclaration(p) {
        const schema = parseJSDocs(
          (p.parent.leadingComments || []).filter((c) => c.type === "CommentBlock").map((c) => c.value)
        );
        schema.type = "function";
        schema.args = [];
        if (!schema.tags.includes("@untyped")) {
          return;
        }
        const _getLines = utils.cachedFn(() => this.file.code.split("\n"));
        const getCode = (loc) => {
          const _lines = _getLines();
          return _lines[loc.start.line - 1].slice(loc.start.column, loc.end.column).trim() || "";
        };
        for (const [index, param] of p.node.params.entries()) {
          if (param.loc?.end.line !== param.loc?.start.line) {
            continue;
          }
          if (!t__namespace.isAssignmentPattern(param) && !t__namespace.isIdentifier(param)) {
            continue;
          }
          const lparam = t__namespace.isAssignmentPattern(param) ? param.left : param;
          if (!t__namespace.isIdentifier(lparam)) {
            continue;
          }
          const arg = {
            name: lparam.name || "arg" + index,
            optional: lparam.optional || void 0
          };
          if (lparam.typeAnnotation) {
            Object.assign(
              arg,
              utils.mergedTypes(
                arg,
                inferAnnotationType(lparam.typeAnnotation, getCode)
              )
            );
          }
          if (param.type === "AssignmentPattern") {
            Object.assign(
              arg,
              utils.mergedTypes(arg, inferArgType(param.right))
            );
          }
          schema.args = schema.args || [];
          schema.args.push(arg);
        }
        if (p.node.returnType?.type === "TSTypeAnnotation") {
          schema.returns = inferAnnotationType(p.node.returnType, getCode);
        }
        schema.tags = schema.tags?.filter((tag) => {
          if (tag.startsWith("@returns")) {
            const { type } = tag.match(/^@returns\s+{(?<type>[\S\s]+)}/)?.groups || {};
            if (